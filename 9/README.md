# 第9章 应用设计开发
## 9.1 应用程序和用户界面
* 从`客户-服务器`架构演变到`浏览器-服务器`架构
## 9.2 Web基础
### 9.2.1 统一资源定位符
* Uniform Resource Locator
### 9.2.2 超文本标记语言
### 9.2.3 Web服务器和会话
#### Web服务器
* `Web服务器(Web Server)`是运行于服务器上的程序，它接受来自于Web浏览器的请求并以HTML文档的形式返回结果。
* `公共网关接口(Common Gateway Interface, CGI)`标准定义了Web服务器如何与应用程序通信。
* 三层Web应用体系结构：浏览器<-网络->服务器(Web服务器<->应用服务器<->数据库服务器)
* 两层Web应用体系结构：浏览器<-网路->服务器(Web服务器和应用服务器<->数据库服务器)
#### 会话
* 会话的产生背景：在客户端与Web服务器之间不存在持续的连接；具体表现为：当Web服务器接收到一个请求时，临时创建一个连接以发送请求并接收来自Web服务器的响应。但是该连接可能会关闭，且下一个请求可以生成一个新的连接。
* 需求：当一个用户登录计算机，或是使用ODBC或JDBC连接到数据库时，会创建一个会话，且会话信息保留在服务端和客户端，直到会话结束——信息包括诸如该用户的用户标识符和用户已设置的会话参数等。
* HTTP协议是`无连接`(connectionless)的一个重要原因在于，打过书计算机能同时容纳的连接数目是有限的。如果Web中大量的站点对单台服务器建立连接，就会超过限制，拒绝后续用户的服务。而使用无连接协议，当满足了请求时连接就可以马上断开，为其他请求留出可用连接。
* 尽管连接会关闭，但为了实现会话，需要在客户端存储额外的信息，并随会话中的每个请求返回；服务器使用这个信息来辨别出请求是用户会话的一部分。关于会话的额外信息同样必须在服务器端维护。
* 这种额外信息通常以`网络跟踪器`(cookie)的形式保存在客户端。
* 一个域(Web站点)只能获取它自己设置的cookie，而不能得到别的站点设置的cookie，而且cookie名可以跨域复用。
* 流程：应用程序产生一个会话标识符（通常是一个当前没有用作会话标识符的随机数），然后发送一个包含这个会话标识符的名为（比如）sessionid的cookie。该会话标识符也保存在服务器本地。当一个请求进来时，应用服务器向客户端请求名为sessionid的cookie。如果客户端没有存储该cookie，或者返回的值不是当前在服务器中记录的有效会话标识符，应用程序就认为该请求不是当前会话的一部分。如果cookie的值与一个存储的会话标识符匹配，则该请求就被识别为一个进行中的会话的一部分。
* 如果一个应用需要安全地鉴别用户，则它只能在对用户认证之后设置cookie；例如，用户只有在提交了有效的用户名和密码之后才能通过认证。
* 注释二解释了session的作用：假如用户标识符存储在客户端一个叫做userid的cookie中，cookie中的值可能在浏览器中被用户恶意篡改，该用户就能够伪装成另一个用户。将cookie（比如名为sessionid）设置为一个随机产生的会话标识符（一个很大的数字空间），可以使得一个用户冒充另一个用户的可能性变得极小。而一个顺序生成的会话标识符，则很容易冒充。
* cookie可以选择保存期限。
* 通常用户通过点击一个注销按钮来注销，它会提交一个注销表单，其动作就是使当前会话失效。
* 使当前会话失效仅仅是在应用服务器中的活动会话列表里丢弃该会话标识符。
